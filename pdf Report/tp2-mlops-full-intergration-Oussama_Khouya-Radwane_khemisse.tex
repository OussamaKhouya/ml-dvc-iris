\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{float}
\usepackage[all]{hypcap} % corrige la position des liens vers les figures

% Minimal definitions so listings understands YAML/INI without errors
\lstdefinelanguage{yaml}{}
\lstdefinelanguage{YAML}{}
\lstdefinelanguage{ini}{}
\lstdefinelanguage{INI}{}

% Allow graphics to be found whether latexmk is run
% from the repo root or from this pdf Report directory
\graphicspath{{../snapshots/}{snapshots/}}

\geometry{margin=1.5cm}
\hypersetup{colorlinks=true, linkcolor=blue, urlcolor=blue}

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{teal},
  frame=single,
  breaklines=true,
  escapeinside=@@
}

\title{TP2 -- Intégration MLOps complète\\
\small (GitHub Actions, DVC, CML, Docker, Google Drive)}
\author{Oussama Khouya \and Radwane Khemisse \and Achrafe Elalaoui}
\date{December 8, 2025}

\begin{document}
\maketitle

\section{Contexte et objectifs}
Contexte : projet \texttt{ml-dvc-iris} du TP1 (dataset Iris, pipeline DVC).

Objectifs du TP2 :
\begin{enumerate}
  \item Intégrer le pipeline DVC dans un workflow GitHub Actions.
  \item Générer un rapport de métriques avec CML dans les Pull Requests.
  \item Configurer un remote DVC Google Drive pour les données et artefacts.
  \item Préparer un Dockerfile et la promotion du meilleur modèle vers \texttt{models/production\_model.pkl}.
\end{enumerate}

\section{Architecture MLOps mise en place}
L'architecture MLOps repose sur un pipeline DVC défini dans \texttt{dvc.yaml} avec plusieurs stages et le suivi des données et artefacts (\texttt{data/iris.csv}, \texttt{data/iris\_preprocessed.csv}, \texttt{models/random\_forest.pkl}, \texttt{metrics/*.json}). Un remote DVC \texttt{new\_gdrive} sur Google Drive est configuré pour stocker ces artefacts. Un workflow GitHub Actions \texttt{mlops-pipeline.yaml} exécute automatiquement \texttt{dvc pull}, \texttt{dvc repro} et le script \texttt{scripts/generate\_cml\_report.py} afin de produire un rapport CML et un commentaire automatique sur les Pull Requests, en préparation d'une future containerisation Docker et d'un stage \texttt{deploy} pour promouvoir le meilleur modèle.


\section{Vériﬁcation du projet de départ}
\noindent Les vérifications de base du projet se font en deux étapes :
\begin{enumerate}
  \item Cloner (ou mettre à jour) le projet \texttt{ml-dvc-iris} sur la machine locale.
  \item Vérifier que la commande suivante s'exécute localement : \texttt{dvc repro} (\autoref{fig:dvc-repro}).
\end{enumerate}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.65\linewidth]{dvc repro.png}
  \caption{Exécution locale du pipeline \texttt{dvc repro}}
  \label{fig:dvc-repro}
\end{figure}

\section{Workﬂow GitHub Actions avec DVC et CML}
\subsection{Exécution réussie du pipeline GitHub Actions}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\linewidth]{successful-workflow.png}
  \caption{Exécution réussie du pipeline GitHub Actions}
  \label{fig:ci-ok}
\end{figure}

\subsection{Commentaire CML dans une Pull Request}
\begin{figure}[h]
  \centering
  \includegraphics[width=0.4\linewidth]{cml-comment.png}
  \caption{Commentaire CML généré dans la Pull Request}
  \label{fig:cml-comment}
\end{figure}

\section{Remote DVC Google Drive}
\begin{itemize}
  \item Remote \texttt{new\_gdrive} pointant vers l'ID Drive, authentifié via secrets OAuth.
\begin{lstlisting}[language=ini,caption={Extrait .dvc/config},label={lst:dvc-config}]
[core]
    remote = new_gdrive

[remote "new_gdrive"]
    url = gdrive://1qnTG-xYstcnUbljTv94pp2izEqLpBP-o
    gdrive_use_service_account = true
    gdrive_service_account_json_file_path = /home/oldhome/pc/enset/_S3/DevOps/dvc/gdrive_user_credentials.json
\end{lstlisting}
  \item Synchronisation vérifiée : \texttt{dvc pull} (\autoref{fig:dvc-pull}) et \texttt{dvc push} (\autoref{fig:dvc-push}).
   

\begin{figure}[h]
  \centering
  \includegraphics[width=0.65\linewidth]{dvc pull.png}
  \caption{Récupération des artefacts par \texttt{dvc pull}}
  \label{fig:dvc-pull}
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.65\linewidth]{dvc push up to date.png}
  \caption{\texttt{dvc push} indiquant un cache distant à jour}
  \label{fig:dvc-push}
\end{figure}
  
  \item Structure de Remote DVC (google drive):  (\autoref{fig:dvc-structure}).
\end{itemize}




\begin{figure}[h]
  \centering
  \includegraphics[width=0.4\linewidth]{google-drive-dvc-folder-structure.png}
  \caption{structure dossier dvc (\texttt{google drive})}
  \label{fig:dvc-structure}
\end{figure}

\section{Containerisation Docker}
\subsection{Création du fichier Dockerfile}
À la racine du projet, nous créons un fichier \texttt{Dockerfile} qui part de l'image \texttt{python:3.11-slim}, installe les dépendances et lance \texttt{dvc repro} par défaut. Extrait :

\begin{lstlisting}[language=bash,caption={Extrait du fichier Dockerfile},label={lst:dockerfile}]
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["dvc", "repro"]
\end{lstlisting}

\subsection{Construction de l'image et test local sur un conteneur}
Étapes :
\begin{enumerate}
  \item Construire l'image : \texttt{docker build -t ml-dvc-iris:latest .} (\autoref{fig:dvc-build}).
  \item Lancer un conteneur de test : \texttt{docker run --rm ml-dvc-iris:latest} (\autoref{fig:docker-run}).
\end{enumerate}


\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\linewidth]{docker-build.png}
  \caption{docker buid output (\texttt{google drive})}
  \label{fig:dvc-build}
\end{figure}

\begin{figure}[H]
  \centering
   \includegraphics[width=0.5\linewidth]{docker-run.png}
  \caption{Exécution du conteneur Docker}
  \label{fig:docker-run}
\end{figure}


\section{Difficultés rencontrées et solutions}
\begin{itemize}
  \item Docker build très long (48 minutes) pour construire l'image \texttt{ml-dvc-iris:latest} (voir \autoref{fig:dvc-build}).
  \item \texttt{iris.csv} non versionné par DVC car seulement \emph{deps} et non \emph{out}. Solution : ajouter \texttt{iris.csv} comme \emph{out} dans \texttt{dvc.yaml} et faire \texttt{dvc push}.
\end{itemize}

\begin{lstlisting}[language=YAML,caption={Extrait du nouveau fichier dvc.yaml},label={lst:dvc-yaml}]
stages:
  download:
    cmd: python scripts/download_iris.py
    deps:
      - scripts/download_iris.py
    outs:
      - @\colorbox{yellow!30}{data/iris.csv}@

  prepare:
    cmd: python scripts/preprocess.py
    deps:
      - scripts/preprocess.py
      - data/iris.csv
    outs:
      - data/iris_preprocessed.csv
\end{lstlisting}

\section{Conclusion}

En résumé, la chaîne MLOps mise en place combine DVC (pipeline et versionnement des données/modèles), un remote Google Drive pour les artefacts, un workflow GitHub Actions avec CML pour l'exécution automatique et le rapport dans les PR, ainsi qu'un Dockerfile pour rejouer le pipeline dans un conteneur de façon reproductible.

\end{document}
